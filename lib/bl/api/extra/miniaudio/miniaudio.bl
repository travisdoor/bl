#import "std/sync"

#scope miniaudio

MA_MAX_NODE_LOCAL_BUS_COUNT :: 2;
MA_ENGINE_MAX_LISTENERS  :: 4;
MA_SIZEOF_PTR : usize : 8;
MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT :: 64;
MA_MAX_LOG_CALLBACKS :: 4;

ma_int8 :: s8;
ma_uint8 :: u8;
ma_int16 :: s16;
ma_uint16 :: u16;
ma_int32 :: s32;
ma_uint32 :: u32;
ma_int64 :: s64;
ma_uint64 :: u64;
ma_bool8 :: s8;
ma_bool32 :: s32;

ma_mutex :: [size_of_mutex()]u8;

ma_node_vtable :: u8;
ma_data_source_vtable :: u8;
ma_decoding_backend_vtable :: u8;
ma_resampling_backend_vtable ::u8;

ma_node :: u8;
ma_spinlock :: u32;

ma_data_source :: u8;
ma_resampling_backend :: u8;
ma_vfs :: u8;
ma_handle :: C.void_ptr;
ma_vfs_file :: ma_handle;

MA_ATOMIC :: fn (alignment: usize, T: type #comptime) type #comptime {
    // @Incomplete: we cannot specify type alignment now in the language, so do just some validation for now.
    alignment;
    assert(alignof(T) == alignment);
    return T;
}

ma_device_type :: enum {
    DEVICE_TYPE_PLAYBACK = 1;
    DEVICE_TYPE_CAPTURE  = 2;
    DEVICE_TYPE_DUPLEX   = DEVICE_TYPE_PLAYBACK | DEVICE_TYPE_CAPTURE;
    DEVICE_TYPE_LOOPBACK = 4;
}

ma_enum_devices_callback_proc :: *fn (pContext: *ma_context, deviceType: ma_device_type, pInfo: *ma_device_info, pUserData: C.void_ptr) ma_bool32;

ma_backend_callbacks :: struct {
    onContextInit: *fn (pContext: *ma_context, pConfig: *ma_context_config, pCallbacks: *ma_backend_callbacks) ma_result;
    onContextUninit: *fn (pContext: *ma_context) ma_result;
    onContextEnumerateDevices: *fn (pContext: *ma_context, callback: ma_enum_devices_callback_proc, pUserData: C.void_ptr) ma_result;
    onContextGetDeviceInfo: *fn (pContext: *ma_context, deviceType: ma_device_type, pDeviceID: *ma_device_id, pDeviceInfo: *ma_device_info) ma_result;
    onDeviceInit: *fn (pDevice: *ma_device, pConfig: *ma_device_config, pDescriptorPlayback: *ma_device_descriptor, pDescriptorCapture: *ma_device_descriptor) ma_result;
    onDeviceUninit: *fn (pDevice: *ma_device) ma_result;
    onDeviceStart: *fn (pDevice: *ma_device) ma_result;
    onDeviceStop: *fn (pDevice: *ma_device) ma_result;
    onDeviceRead: *fn (pDevice: *ma_device, pFrames: C.void_ptr, frameCount: ma_uint32, pFramesRead: *ma_uint32) ma_result;
    onDeviceWrite: *fn (pDevice: *ma_device, pFrames: C.void_ptr, frameCount: ma_uint32, pFramesWritten: *ma_uint32) ma_result;
    onDeviceDataLoop: *fn (pDevice: *ma_device) ma_result;
    onDeviceDataLoopWakeup: *fn (pDevice: *ma_device) ma_result;
    onDeviceGetInfo: *fn (pDevice: *ma_device, device_type: ma_device_type, pDeviceInfol: *ma_device_info) ma_result;
}

ma_thread_priority :: enum {
    THREAD_PRIORITY_IDLE     = -5;
    THREAD_PRIORITY_LOWEST   = -4;
    THREAD_PRIORITY_LOW      = -3;
    THREAD_PRIORITY_NORMAL   = -2;
    THREAD_PRIORITY_HIGH     = -1;
    THREAD_PRIORITY_HIGHEST  =  0;
    THREAD_PRIORITY_REALTIME =  1;
    THREAD_PRIORITY_DEFAULT  =  0;
}

ma_ios_session_category :: enum {
    IOS_SESSION_CATEGORY_DEFAULT = 0;
    IOS_SESSION_CATEGORY_NONE;
    IOS_SESSION_CATEGORY_AMBIENT;
    IOS_SESSION_CATEGORY_SOLO_AMBIENT;
    IOS_SESSION_CATEGORY_PLAYBACK;
    IOS_SESSION_CATEGORY_RECORD;
    IOS_SESSION_CATEGORY_PLAY_AND_RECORD;
    IOS_SESSION_CATEGORY_MULTI_ROUTE;
}

ma_context_config :: struct {
    pLog: *ma_log;
    threadPriority: ma_thread_priority;
    threadStackSize: usize;
    pUserData: C.void_ptr;
    allocationCallbacks: ma_allocation_callbacks;
    alsa: struct {
        useVerboseDeviceEnumeration: ma_bool32;
    };
    pulse: struct {
        pApplicationName: *C.char;
        pServerName: *C.char;
        tryAutoSpawn: ma_bool32;
    };
    coreaudio: struct {
        sessionCategory: ma_ios_session_category;
        sessionCategoryOptions: ma_uint32;
        noAudioSessionActivate: ma_bool32;
        noAudioSessionDeactivate: ma_bool32;
    };
    jack: struct {
        pClientName: *C.char;
        tryStartServer: ma_bool32;
    };
    custom: ma_backend_callbacks;
}

ma_sound_flags :: enum {
    SOUND_FLAG_STREAM                = 0x00000001;
    SOUND_FLAG_DECODE                = 0x00000002;
    SOUND_FLAG_ASYNC                 = 0x00000004;
    SOUND_FLAG_WAIT_INIT             = 0x00000008;
    SOUND_FLAG_NO_DEFAULT_ATTACHMENT = 0x00000010;
    SOUND_FLAG_NO_PITCH              = 0x00000020;
    SOUND_FLAG_NO_SPATIALIZATION     = 0x00000040;
}

ma_sound_config :: struct {
    pFilePath: *C.char;
    pFilePathW: *u8; // @Incomplete: originally *wchar_t
    pDataSource: *ma_data_source;
    pInitialAttachment: ma_node;
    initialAttachmentInputBusIndex: ma_uint32;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    flags: ma_uint32;
    initialSeekPointInPCMFrames: ma_uint64;
    rangeBegInPCMFrames: ma_uint64;
    rangeEndInPCMFrames: ma_uint64;
    loopPointBegInPCMFrames: ma_uint64;
    loopPointEndInPCMFrames: ma_uint64;
    isLooping: ma_bool32;
    pDoneFence: *ma_fence;
}

ma_sound_group_config :: ma_sound_config;
ma_sound_group :: ma_sound;

ma_sound_inlined :: struct {
    sound: ma_sound;
    pNext: *ma_sound_inlined;
    pPrev: *ma_sound_inlined;
}

ma_resource_manager_data_stream :: struct {
    ds: ma_data_source_base;
    pResourceManager: *ma_resource_manager;
    flags: ma_uint32;
    decoder: ma_decoder;
    isDecoderInitialized: ma_bool32;
    totalLengthInPCMFrames: ma_uint64;
    relativeCursor: ma_uint32;
    absoluteCursor: MA_ATOMIC(8, ma_uint64);
    currentPageIndex: ma_uint32;
    executionCounter: MA_ATOMIC(4, ma_uint32);
    executionPointer: MA_ATOMIC(4, ma_uint32);
    isLooping: MA_ATOMIC(4, ma_bool32);
    pPageData: C.void_ptr;
    pageFrameCount: [2]MA_ATOMIC(4, ma_uint32);
    result: MA_ATOMIC(4, ma_result);
    isDecoderAtEnd: MA_ATOMIC(4, ma_bool32);
    isPageValid: [2]MA_ATOMIC(4, ma_bool32);
    seekCounter: MA_ATOMIC(4, ma_bool32);
}

ma_resource_manager_data_source :: struct {
    backend: union {
        buffer: ma_resource_manager_data_buffer;
        stream: ma_resource_manager_data_stream;
    };

    flags: ma_uint32;
    executionCounter: MA_ATOMIC(4, ma_uint32);
    executionPointer: MA_ATOMIC(4, ma_uint32);
}

ma_paged_audio_buffer ::struct {
    ds: ma_data_source_base;
    pData: *ma_paged_audio_buffer_data;
    pCurrent: *ma_paged_audio_buffer_page;
    relativeCursor: ma_uint64;
    absoluteCursor: ma_uint64;
}

ma_resource_manager_data_buffer :: struct {
    ds: ma_data_source_base;
    pResourceManager: *ma_resource_manager;
    pNode: *ma_resource_manager_data_buffer_node;
    flags: ma_uint32;
    executionCounter: MA_ATOMIC(4, ma_uint32);
    executionPointer: MA_ATOMIC(4, ma_uint32);
    seekTargetInPCMFrames: ma_uint64;
    seekToCursorOnNextRead: ma_bool32;
    result: MA_ATOMIC(4, ma_result);
    isLooping: MA_ATOMIC(4, ma_bool32);
    isConnectorInitialized: ma_bool32;
    connector: union {
        decoder: ma_decoder;
        buffer: ma_audio_buffer;
        pagedBuffer: ma_paged_audio_buffer;
    };
}

ma_seek_origin :: enum {
    SEEK_ORIGIN_START;
    SEEK_ORIGIN_CURRENT;
    SEEK_ORIGIN_END;
}

ma_decoder_read_proc :: *fn (pDecoder: *ma_decoder, pBufferOut: C.void_ptr, bytesToRead: usize, pBytesRead: *usize) ma_result;
ma_decoder_seek_proc :: *fn (pDecoder: *ma_decoder, byteOffset: ma_int64, origin: ma_seek_origin) ma_result;
ma_decoder_tell_proc :: *fn (pDecoder: *ma_decoder, pCursor: *ma_int64, origin: ma_seek_origin) ma_result;

ma_decoder :: struct {
    ds: ma_data_source_base;
    pBackend: *ma_data_source;
    pBackendVTable: *ma_decoding_backend_vtable;
    pBackendUserData: C.void_ptr;
    onRead: ma_decoder_read_proc;
    onSeek: ma_decoder_seek_proc;
    onTell: ma_decoder_tell_proc;
    pUserData: C.void_ptr;
    readPointerInPCMFrames: ma_uint64;
    outputFormat: ma_format;
    outputChannels: ma_uint32;
    outputSampleRate: ma_uint32;
    converter: ma_data_converter;
    pInputCache: C.void_ptr;
    inputCacheCap: ma_uint64;
    inputCacheConsumed: ma_uint64;
    inputCacheRemaining: ma_uint64;
    allocationCallbacks: ma_allocation_callbacks;
    data: union {
        vfs: struct {
            pVFS: *ma_vfs;
            file: ma_vfs_file;
        };
        memory: struct {
            pData: *ma_uint8;
            dataSize: usize;
            currentReadPos: usize;
        };
    };
}

ma_audio_buffer_ref :: struct {
    ds: ma_data_source_base;
    format: ma_format;
    channels: ma_uint32;
    cursor: ma_uint64;
    sizeInFrames: ma_uint64 ;
    pData: C.void_ptr;
}

ma_audio_buffer :: struct {
    ref: ma_audio_buffer_ref;
    allocationCallbacks: ma_allocation_callbacks;
    ownsData: ma_bool32;
    _pExtraData: [1]ma_uint8;
}

ma_channel_converter :: struct {
    format: ma_format;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    mixingMode: ma_channel_mix_mode;
    conversionPath: ma_channel_conversion_path;
    pChannelMapIn: *ma_channel;
    pChannelMapOut: *ma_channel ;
    pShuffleTable: ma_uint8;
    weights: union {
        float: **f32;
        int16: **s16;
    };

    /* Memory management. */
    _pHeap: C.void_ptr;
    _ownsHeap: ma_bool32;
}

ma_channel_conversion_path :: enum {
    CHANNEL_CONVERSION_PATH_UNKNOWN;
    CHANNEL_CONVERSION_PATH_PASSTHROUGH;
    CHANNEL_CONVERSION_PATH_MONO_OUT;
    CHANNEL_CONVERSION_PATH_MONO_IN;
    CHANNEL_CONVERSION_PATH_SHUFFLE;
    CHANNEL_CONVERSION_PATH_WEIGHTS;
}

ma_channel_mix_mode :: enum {
    CHANNEL_MIX_MODE_RECTANGULAR = 0;
    CHANNEL_MIX_MODE_SIMPLE;
    CHANNEL_MIX_MODE_CUSTOM_WEIGHTS;
    CHANNEL_MIX_MODE_DEFAULT = CHANNEL_MIX_MODE_RECTANGULAR;
}

ma_data_converter :: struct {
    formatIn: ma_format;
    formatOut: ma_format;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    ditherMode: ma_dither_mode;
    executionPath: ma_data_converter_execution_path;
    channelConverter: ma_channel_converter;
    resampler: ma_resampler;
    hasPreFormatConversion: ma_bool8;
    hasPostFormatConversion: ma_bool8;
    hasChannelConverter: ma_bool8;
    hasResampler: ma_bool8;
    isPassthrough: ma_bool8;

    /* Memory management. */
    _ownsHeap: ma_bool8;
    _pHeap: C.void_ptr;
}

ma_resample_algorithm :: enum {
    RESAMPLE_ALGORITHM_LINEAR;
    RESAMPLE_ALGORITHM_CUSTOM;
}

ma_resampler_config :: struct  {
    format: ma_format;
    channels: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    algorithm: ma_resample_algorithm;
    pBackendVTable: *ma_resampling_backend_vtable;
    pBackendUserData: C.void_ptr;
    linear: struct {
        lpfOrder: ma_uint32;
    };
};

ma_resampler :: struct {
    pBackend: *ma_resampling_backend;
    pBackendVTable: *ma_resampling_backend_vtable;
    pBackendUserData: C.void_ptr;
    format: ma_format;
    channels: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    state: union {
        linear: ma_linear_resampler;
    };

    /* Memory management. */
    _pHeap: C.void_ptr;
    _ownsHeap: ma_bool32;
}

ma_dither_mode :: enum {
    DITHER_MODE_NONE = 0;
    DITHER_MODE_RECTANGLE;
    DITHER_MODE_TRIANGLE;
}

ma_data_converter_execution_path :: enum {
    DATA_CONVERTER_EXECUTION_PATH_PASSTHROUGH;
    DATA_CONVERTER_EXECUTION_PATH_FORMAT_ONLY;
    DATA_CONVERTER_EXECUTION_PATH_CHANNELS_ONLY;
    DATA_CONVERTER_EXECUTION_PATH_RESAMPLE_ONLY;
    DATA_CONVERTER_EXECUTION_PATH_RESAMPLE_FIRST;
    DATA_CONVERTER_EXECUTION_PATH_CHANNELS_FIRST;
}

ma_data_source_base :: struct {
    vtable: *ma_data_source_vtable;
    rangeBegInFrames: ma_uint64;
    rangeEndInFrames: ma_uint64;
    loopBegInFrames: ma_uint64;
    loopEndInFrames: ma_uint64;
    pCurrent: *ma_data_source;
    pNext: *ma_data_source;
    onGetNext: ma_data_source_get_next_proc;
    isLooping: MA_ATOMIC(4, ma_bool32);
}

ma_data_source_get_next_proc :: *fn (pDataSource: ma_data_source) *ma_data_source;

ma_resource_manager_data_buffer_node :: struct {
    hashedName32: ma_uint32;
    refCount: ma_uint32;
    result: MA_ATOMIC(4, ma_result);
    executionCounter: MA_ATOMIC(4, ma_uint32);
    executionPointer: MA_ATOMIC(4, ma_uint32);
    isDataOwnedByResourceManager: ma_bool32;
    data: ma_resource_manager_data_supply;
    pParent: *ma_resource_manager_data_buffer_node;
    pChildLo: *ma_resource_manager_data_buffer_node;
    pChildHi: *ma_resource_manager_data_buffer_node;
}

ma_resource_manager_data_supply_type :: enum {
    RESOURCE_MANAGER_DATA_SUPPLY_TYPE_UNKNOWN = 0;
    RESOURCE_MANAGER_DATA_SUPPLY_TYPE_ENCODED;
    RESOURCE_MANAGER_DATA_SUPPLY_TYPE_DECODED;
    RESOURCE_MANAGER_DATA_SUPPLY_TYPE_DECODED_PAGED;
}

ma_resource_manager_data_supply :: struct {
    type: MA_ATOMIC(4, ma_resource_manager_data_supply_type);
    backend: union {
        encoded: struct {
            pData: C.void_ptr;
            sizeInBytes: usize;
        };
        decoded: struct {
            pData: C.void_ptr;
            totalFrameCount: ma_uint64;
            decodedFrameCount: ma_uint64;
            format: ma_format;
            channels: ma_uint32;
            sampleRate: ma_uint32;
        };
        decodedPaged: struct {
            data: ma_paged_audio_buffer_data;
            decodedFrameCount: ma_uint64;
            sampleRate: ma_uint32;
        };
    };
}

ma_paged_audio_buffer_page :: struct {
    pNext: MA_ATOMIC(MA_SIZEOF_PTR, *u8); // @Incomplete: *u8 instead of ma_paged_audio_buffer_page
    sizeInFrames: ma_uint64;
    pAudioData: [1]ma_uint8;
}

ma_paged_audio_buffer_data :: struct {
    format: ma_format;
    channels: ma_uint32;
    head: ma_paged_audio_buffer_page;
    pTail: MA_ATOMIC(MA_SIZEOF_PTR, *ma_paged_audio_buffer_page);
}

ma_format :: enum {
    FORMAT_UNKNOWN = 0;
    FORMAT_U8      = 1;
    FORMAT_S16     = 2;
    FORMAT_S24     = 3;
    FORMAT_S32     = 4;
    FORMAT_F32     = 5;
}

ma_linear_resampler_config :: struct {
    format: ma_format;
    channels: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    lpfOrder: ma_uint32;
    lpfNyquistFactor: f64;
}

ma_linear_resampler :: struct {
    config: ma_linear_resampler_config;
    inAdvanceInt: ma_uint32;
    inAdvanceFrac: ma_uint32;
    inTimeInt: ma_uint32;
    inTimeFrac: ma_uint32;
    x0: union {
        float: *f32;
        int16: *s16;
    };
    x2: union {
        float: *f32;
        int16: *s16;
    };
    lpf: ma_lpf;

    _pHeap: C.void_ptr;
    _ownsHeap: ma_bool32;
};

ma_spatializer :: struct {
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    pChannelMapIn: *ma_channel;
    attenuationModel: ma_attenuation_model;
    positioning: ma_positioning;
    handedness: ma_handedness;
    minGain: f32;
    maxGain: f32;
    minDistance: f32;
    maxDistance: f32;
    rolloff: f32;
    coneInnerAngleInRadians: f32;
    coneOuterAngleInRadians: f32;
    coneOuterGain: f32;
    dopplerFactor: f32 ;
    directionalAttenuationFactor: f32;
    gainSmoothTimeInFrames: ma_uint32;
    position: ma_vec3f;
    direction: ma_vec3f;
    velocity: ma_vec3f ;
    dopplerPitch: f32;
    gainer: ma_gainer;
    pNewChannelGainsOut: f32;

    /* Memory management. */
    _pHeap: C.void_ptr;
    _ownsHeap: ma_bool32;
};

ma_attenuation_model :: enum {
    ATTENUATION_MODEL_NONE;
    ATTENUATION_MODEL_INVERSE;
    ATTENUATION_MODEL_LINEAR;
    ATTENUATION_MODEL_EXPONENTIAL;
};

ma_engine_node :: struct {
    baseNode: ma_node_base;
    pEngine: *ma_engine;
    sampleRate: ma_uint32;
    fader: ma_fader;
    resampler: ma_linear_resampler;
    spatializer: ma_spatializer;
    panner: ma_panner;
    pitch: MA_ATOMIC(4, f32);
    oldPitch: f32;
    oldDopplerPitch: f32;
    isPitchDisabled: MA_ATOMIC(4, ma_bool32);
    isSpatializationDisabled: MA_ATOMIC(4, ma_bool32);
    pinnedListenerIndex: MA_ATOMIC(4, ma_uint32);

    /* Memory management. */
    _ownsHeap: ma_bool8;
    _pHeap: C.void_ptr;
};

ma_lpf :: struct {
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    lpf1Count: ma_uint32;
    lpf2Count: ma_uint32;
    pLPF1: *ma_lpf1;
    pLPF2: *ma_lpf2;

    /* Memory management. */
    _ownsHeap: ma_bool8;
    _pHeap: C.void_ptr;
};

ma_lpf1 :: struct {
    format: ma_format;
    channels: ma_uint32;
    a: ma_biquad_coefficient;
    pR1: *ma_biquad_coefficient;

    /* Memory management. */
    _pHeap: C.void_ptr;
    _ownsHeap: ma_bool8;
};

ma_lpf2 :: struct {
    bq: ma_biquad;
};

ma_biquad_coefficient :: union {
    float: f32;
    int: s32;
};

ma_biquad_config :: struct {
    format: ma_format;
    channels: ma_uint32;
    b0: f64;
    b1: f64;
    b2: f64;
    a0: f64;
    a1: f64;
    a2: f64;
};

ma_biquad :: struct {
    format: ma_format;
    channels: ma_uint32;
    b0: ma_biquad_coefficient;
    b1: ma_biquad_coefficient;
    b2: ma_biquad_coefficient;
    a1: ma_biquad_coefficient;
    a2: ma_biquad_coefficient;
    pR1: *ma_biquad_coefficient;
    pR2: *ma_biquad_coefficient;

    /* Memory management. */
    _pHeap: C.void_ptr;
    _ownsHeap: ma_bool8;
};

ma_fader_config :: struct {
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
};

ma_fader :: struct {
    config: ma_fader_config;
    volumeBeg: f32;
    volumeEnd: f32;
    lengthInFrames: ma_uint64;
    cursorInFrames: ma_uint64;
};

ma_sound :: struct {
    engineNode: ma_engine_node;
    pDataSource: *ma_data_source;
    seekTarget: ma_uint64;

    atEnd: MA_ATOMIC(4, ma_bool32);
    ownsDataSource: ma_bool8;
    pResourceManagerDataSource: *ma_resource_manager_data_source;
};

ma_node_output_bus :: struct {
    pNode: *ma_node;
    outputBusIndex: u8;
    channels: u8;

    inputma_node_input_busIndex: u8;
    flags: u32;
    refCount: u32;
    isAttached: u32;
    lock: ma_spinlock;
    volume: f32;
    pNext: *ma_node_output_bus;
    pPrev: *ma_node_output_bus;
    pInputNode: *ma_node;
}

ma_node_input_bus :: struct {
    head: ma_node_output_bus;
    nextCounter: u32;
    lock: ma_spinlock;
    channels: u8;
}

ma_node_graph :: struct {
    base: ma_node_base;
    endpoint: ma_node_base;
    nodeCacheCapInFrames: u16;
    isReading: u32;
}

ma_node_state :: enum {
    NODE_STATE_STARTED = 0;
    NODE_STATE_STOPPED = 1;
}

ma_positioning :: enum {
    MA_POSITIONING_ABSOLUTE;
    MA_POSITIONING_RELATIVE;
}

ma_node_base :: struct {
    pNodeGraph: *ma_node_graph;
    vtable: *ma_node_vtable;
    pCachedData: *f32;
    cachedDataCapInFramesPerBus: u16;
    cachedFrameCountOut: u16;
    cachedFrameCountIn: u16;
    consumedFrameCountIn: u16;

    state: ma_node_state;
    stateTimes: [2]u64;
    localTime: u64;
    inputBusCount: u32;
    outputBusCount: u32;
    pInputBuses: *ma_node_input_bus;
    pOutputBuses: *ma_node_output_bus;

    _inputBuses:  [MA_MAX_NODE_LOCAL_BUS_COUNT]ma_node_input_bus;
    _outputBuses: [MA_MAX_NODE_LOCAL_BUS_COUNT]ma_node_output_bus;
    _pHeap: *u8;
    _ownsHeap: u32;
}

ma_gainer_config :: struct {
    channels: ma_uint32;
    smoothTimeInFrames: ma_uint32;
}

ma_gainer :: struct {
    config: ma_gainer_config;
    t: ma_uint32;
    pOldGains: *f32;
    pNewGains: *f32;

    /* Memory management. */
    _pHeap: *u8;
    _ownsHeap: u32;
}

ma_panner :: struct{
    format: ma_format;
    channels: ma_uint32;
    mode: ma_pan_mode;
    pan: f32;
}

ma_pan_mode :: enum {
    PAN_MODE_BALANCE = 0;
    PAN_MODE_PAN;
} ;

ma_handedness :: enum {
    HANDEDNESS_RIGHT;
    HANDEDNESS_LEFT;
}

ma_vec3f ::  struct {
    x: f32;
    y: f32;
    z: f32;
}

ma_spatializer_listener_config :: struct {
    channelsOut: u32;
    pChannelMapOut: *ma_channel;
    handedness: ma_handedness;
    coneInnerAngleInRadians: f32;
    coneOuterAngleInRadians: f32;
    coneOuterGain: f32;
    speedOfSound: f32;
    worldUp: ma_vec3f;
}

ma_spatializer_listener :: struct {
    config: ma_spatializer_listener_config;
    position: ma_vec3f;
    direction: ma_vec3f;
    velocity: ma_vec3f;
    isEnabled: u32;

    _ownsHeap: u32;
    _pHeap: *u8;
}

ma_allocation_callbacks :: struct {
    pUserData: *u8;
    onMalloc: *fn (sz: usize, pUserData: *u8) *u8;
    onRealloc: *fn (p: *u8, sz: usize, pUserData: *u8) *u8;
    onFree: *fn (p: *u8, pUserData: *u8);
}

ma_mono_expansion_mode :: enum {
    MONO_EXPANSION_MODE_DUPLICATE = 0;
    MONO_EXPANSION_MODE_AVERAGE;
    MONO_EXPANSION_MODE_STEREO_ONLY;
    MONO_EXPANSION_MODE_DEFAULT = MONO_EXPANSION_MODE_DUPLICATE;
}

ma_engine_config :: struct {
    pResourceManager: *ma_resource_manager;
    pContext: *ma_context;
    pDevice: *ma_device;
    pPlaybackDeviceID: *ma_device_id;
    pLog: *ma_log;
    listenerCount: ma_uint32;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    periodSizeInFrames: ma_uint32;
    periodSizeInMilliseconds: ma_uint32;
    gainSmoothTimeInFrames: ma_uint32;
    gainSmoothTimeInMilliseconds: ma_uint32;
    allocationCallbacks: ma_allocation_callbacks;
    noAutoStart: ma_bool32;
    noDevice: ma_bool32;
    monoExpansionMode: ma_mono_expansion_mode;
    pResourceManagerVFS: *ma_vfs;
}

ma_engine :: struct {
    nodeGraph: ma_node_graph;
    pma_resource_manager: *ma_resource_manager;
    pDevice: *ma_device;
    pLog: *ma_log;
    sampleRate: u32;
    listenerCount: u32;
    listeners: [MA_ENGINE_MAX_LISTENERS]ma_spatializer_listener;
    allocationCallbacks: ma_allocation_callbacks;
    ownsma_resource_manager: u8;
    ownsDevice: u8;
    inlinedSoundLock: ma_spinlock;
    pInlinedSoundHead: *ma_sound_inlined;
    inlinedSoundCount: u32;
    gainSmoothTimeInFrames: u32;
    monoExpansionMode: ma_mono_expansion_mode;
}

ma_result :: enum {
    SUCCESS                        =  0;
    ERROR                          = -1;  /* A generic error. */
    INVALID_ARGS                   = -2;
    INVALID_OPERATION              = -3;
    OUT_OF_MEMORY                  = -4;
    OUT_OF_RANGE                   = -5;
    ACCESS_DENIED                  = -6;
    DOES_NOT_EXIST                 = -7;
    ALREADY_EXISTS                 = -8;
    TOO_MANY_OPEN_FILES            = -9;
    INVALID_FILE                   = -10;
    TOO_BIG                        = -11;
    PATH_TOO_LONG                  = -12;
    NAME_TOO_LONG                  = -13;
    NOT_DIRECTORY                  = -14;
    IS_DIRECTORY                   = -15;
    DIRECTORY_NOT_EMPTY            = -16;
    AT_END                         = -17;
    NO_SPACE                       = -18;
    BUSY                           = -19;
    IO_ERROR                       = -20;
    INTERRUPT                      = -21;
    UNAVAILABLE                    = -22;
    ALREADY_IN_USE                 = -23;
    BAD_ADDRESS                    = -24;
    BAD_SEEK                       = -25;
    BAD_PIPE                       = -26;
    DEADLOCK                       = -27;
    TOO_MANY_LINKS                 = -28;
    NOT_IMPLEMENTED                = -29;
    NO_MESSAGE                     = -30;
    BAD_MESSAGE                    = -31;
    NO_DATA_AVAILABLE              = -32;
    INVALID_DATA                   = -33;
    TIMEOUT                        = -34;
    NO_NETWORK                     = -35;
    NOT_UNIQUE                     = -36;
    NOT_SOCKET                     = -37;
    NO_ADDRESS                     = -38;
    BAD_PROTOCOL                   = -39;
    PROTOCOL_UNAVAILABLE           = -40;
    PROTOCOL_NOT_SUPPORTED         = -41;
    PROTOCOL_FAMILY_NOT_SUPPORTED  = -42;
    ADDRESS_FAMILY_NOT_SUPPORTED   = -43;
    SOCKET_NOT_SUPPORTED           = -44;
    CONNECTION_RESET               = -45;
    ALREADY_CONNECTED              = -46;
    NOT_CONNECTED                  = -47;
    CONNECTION_REFUSED             = -48;
    NO_HOST                        = -49;
    IN_PROGRESS                    = -50;
    CANCELLED                      = -51;
    MEMORY_ALREADY_MAPPED          = -52;

    /* General miniaudio-specific errors. */
    FORMAT_NOT_SUPPORTED           = -100;
    DEVICE_TYPE_NOT_SUPPORTED      = -101;
    SHARE_MODE_NOT_SUPPORTED       = -102;
    NO_BACKEND                     = -103;
    NO_DEVICE                      = -104;
    API_NOT_FOUND                  = -105;
    INVALID_DEVICE_CONFIG          = -106;
    LOOP                           = -107;

    /* State errors. */
    DEVICE_NOT_INITIALIZED         = -200;
    DEVICE_ALREADY_INITIALIZED     = -201;
    DEVICE_NOT_STARTED             = -202;
    DEVICE_NOT_STOPPED             = -203;

    /* Operation errors. */
    FAILED_TO_INIT_BACKEND         = -300;
    FAILED_TO_OPEN_BACKEND_DEVICE  = -301;
    FAILED_TO_START_BACKEND_DEVICE = -302;
    FAILED_TO_STOP_BACKEND_DEVICE  = -303;
};

ma_log_callback_proc :: *fn (pUserData: C.void_ptr, level: ma_uint32, pMessage: *C.char);

ma_log_callback :: struct {
    onLog: ma_log_callback_proc;
    pUserData: C.void_ptr;
}

ma_log :: struct {
    callbacks: [MA_MAX_LOG_CALLBACKS]ma_log_callback;
    callbackCount: ma_uint32;
    allocationCallbacks: ma_allocation_callbacks;
    lock: ma_mutex;
}

ma_engine_init :: fn (pConfig: *ma_engine_config, pEngine: *ma_engine) ma_result #extern;
ma_engine_uninit :: fn (pEngine: *ma_engine) #extern "ma_engine_uninit";
ma_engine_play_sound :: fn (pEngine: *ma_engine, pFilePath: *C.char, pGroup: *ma_sound_group) ma_result #extern;
ma_engine_get_sample_rate :: fn (pEngine: *ma_engine) ma_uint32 #extern;
ma_engine_get_time :: fn (pEngine: *ma_engine) ma_uint64 #extern;
ma_sound_init_from_file :: fn (pEngine: *ma_engine, pFilePath: *C.char, flags: ma_uint32, pGroup: *ma_sound_group, pDoneFence: *ma_fence, pSound: *ma_sound) ma_result #extern;
ma_sound_uninit :: fn (pSound: *ma_sound) #extern;
ma_sound_start :: fn (pSound: *ma_sound) ma_result #extern;
ma_sound_set_start_time_in_pcm_frames :: fn (pSound: *ma_sound, absoluteGlobalTimeInFrames: ma_uint64) #extern;
ma_sound_set_start_time_in_milliseconds :: fn (pSound: *ma_sound, absoluteGlobalTimeInMilliseconds: ma_uint64) #extern;
ma_sound_set_stop_time_in_pcm_frames :: fn (pSound: *ma_sound, absoluteGlobalTimeInFrames: ma_uint64) #extern;
ma_sound_set_stop_time_in_milliseconds :: fn (pSound: *ma_sound, absoluteGlobalTimeInMilliseconds: ma_uint64) #extern;
ma_sound_stop :: fn (pSound: *ma_sound) ma_result #extern;
ma_sound_set_volume :: fn (pSound: *ma_sound, volume: f32) #extern;
ma_sound_get_volume :: fn (pSound: *ma_sound) f32 #extern;
ma_sound_set_pitch :: fn (pSound: *ma_sound, pitch: f32) #extern;
ma_sound_get_pitch :: fn (pSound: *ma_sound) f32 #extern;
ma_volume_db_to_linear :: fn (gain: f32) f32 #extern;
ma_sound_set_fade_in_pcm_frames :: fn (pSound: *ma_sound, volumeBeg: f32, volumeEnd: f32, fadeLengthInFrames: ma_uint64) #extern;
ma_sound_set_fade_in_milliseconds :: fn (pSound: *ma_sound, volumeBeg: f32, volumeEnd: f32, fadeLengthInMilliseconds: ma_uint64) #extern;
ma_sound_at_end :: fn (pSound: *ma_sound) ma_bool32 #extern;
ma_sound_is_playing :: fn (pSound: *ma_sound) ma_bool32 #extern;
ma_sound_set_looping :: fn (pSound: *ma_sound, isLooping: ma_bool32) #extern;
ma_sound_is_looping :: fn (pSound: *ma_sound) ma_bool32 #extern;
ma_sound_group_init :: fn (pEngine: *ma_engine, flags: ma_uint32, pParentGroup: *ma_sound_group, pGroup: *ma_sound_group) ma_result #extern;
ma_sound_group_uninit :: fn (pGroup: *ma_sound_group) #extern;
ma_context_config_init :: fn () ma_context_config #extern;
ma_context_init :: fn (backends: *ma_backend, backendCount: ma_uint32, pConfig: *ma_context_config, pContext: *ma_context) ma_result #extern;
ma_engine_config_init :: fn () ma_engine_config #extern;
ma_log_callback_init :: fn (onLog: ma_log_callback_proc, pUserData: C.void_ptr) ma_log_callback #extern;

ma_result_to_string :: fn (result: ma_result) string_view {
    info :: cast(*TypeInfoEnum) typeinfo(ma_result);

    loop i := 0; i < info.variants.len; i += 1 {
        variant :: info.variants[i];
        if variant.value == auto result { return variant.name; }
    }
    return "UNKNOWN RESULT";
}

#private

// Just to be sure we have some ABI compatibility.
validate :: fn () #maybe_unused {
#if PLATFORM == Platform.WINDOWS {
    static_assert(sizeof(ma_mutex) == sizeof(ma_handle));
    static_assert(sizeof(ma_log) == 112);
    static_assert(sizeof(ma_engine_config) == 128);
}
}

// This is a bit tricky :/
size_of_mutex :: fn () s32 #comptime {
#if PLATFORM == Platform.WINDOWS {
    return auto sizeof(ma_handle);
} else {
    return auto sizeof(std.Mutex);
}
}

// These are incomplete, we replace them with opaque handles, but keep in mind they must be used only a POINTERS.
ma_resource_manager :: u8;
ma_device :: u8;
ma_channel :: u8;
ma_fence :: u8;
ma_device_info :: u8;
ma_context :: u8;
ma_device_id :: u8;
ma_device_descriptor :: u8;
ma_device_config :: u8;
ma_backend :: u8;
